# This is the script we try following when doing the git show and tell


TOC:
-intro
-most used git commands
-git is just a fancy graph manipulator
-the mysteries of the .git directory
-what is a branch?
-what is a commit and what does it consist of? 
-misc


## intro
started by Linus Torvalds for the Linux kernel
show git README
git is a distributed vcs => NO "master server", everyone has the full repository with the whole history (up to the last fetch)


## most used git commands
quickly look at those commands and which commands would be similar

### adding content
add / reset (/ clean) ~ include / exclude
commit ~ checkin
explain: working dir, staging area, repository

### branching
branch ~ branch
checkout ~ checkout (done automatically)
merge / rebase ~ merge back

### working with remotes
fetch doesn't exist
pull ~ get latest
push ~ checkin

### misc
clone ~ doesn't really exist (get latest)
init ~ ? create repository


## git is just a fancy graph manipulator
Show a picture of a git graph like this one:
in git each commit (and more stuff) is represented by a hash. More to that later.

54f7 <-- db03 <-- 1ed9 <-- ????
  \-- ???? <-- ????-/

Quickly explain HEAD as "the last commit you are currently basing on".
When using commit you just write the content of the staging area into a new commit which references the current HEAD as its parent.
Commit is the "only" party manipulating this graph (only adding)
Everyone else will only manipulate some pointers to the commits (like a branch creates a new ref or checkout moves the HEAD)


## the mysteries of the .git directory
show the git dir:
things in here are most of the time only "valid" locally
config: contains configs for this local repository (not globally for all local repos)
HEAD: contains a commit hash (detached head) or a .refs/heads/xyz hash (normal mode)
hooks: scripts to be called for certain moments in time (like precommit stylecop etc)
index: file which contains the current staging area (formerly known as index) information. The actual file contents are already in objects (done by git add)
logs: folder contains log as to how the HEAD / other refs have been moved.
objects: folder contains all objects. Every version of any file ever added to the repo is an object in here (or in a pack) + all other types of objects like commit, tree, tag, (blob) -> see below.
objects/pack: directory of again zipped object directory -> space saving, triggered through git gc (chron job)
refs: refs and tags

### hash
quick deep dive: show that everything is handled as a hash:
we already know that once something was added to the staging area with add, it will be saved as a git object.
do: create file with content "hello world" (echo "hello world" >. check objects dir. git add file. check objects dir again -> one new file, remember hash.
printf "blob 12\000hello world\n" | sha1sum
show that this is the same hash



## what is a branch?
we should already have seen the git graph and its 'branches'
in git a branch is nothing but a pointer to the tip of such a 'branch'. A pointer to the last commit in such a 'branch'.
do: checkout an early commit (show detached HEAD). Create a branch (show git log showing that commit with the branch name). do some changes and commit. show git dir files: HEAD, refs/heads/master, refs/heads/branchName.
use checkout a bit to checkout both branches one after the other.
explain that the only thing done now is: change HEAD pointer and update working dir



## what is a commit and what does it consist of?
quickly explain blob, tree, commit, tag
do: git log -> last commit id (eg b641). cat-file -t id. (t for type) cat-file -p (p for print)-> content should look familiar. cat-file tree (maybe first -p to show it is a tree) -> see this thing is a folder structure (040000 directory) [mode, type, hash, name]
follow this structure a bit arround and play with it.
- pick a random object in object dir and print it
- pick a random branch and print it
- do not use git log but cat-file with previous commit hash



## misc

### reflog
show reflog and quickly explain how it can rescue you when "git messed up"

### push, pull, fetch
are doing a local branch to remote branch mapping -> pushing = pushing a certain branch -> not all local branches are pushed
fetch = get whole commit graph but to not update refs 
pull = fetch & merge -> merge remote branch into current branch

